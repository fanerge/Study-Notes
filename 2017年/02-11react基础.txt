1.React.createClass 方法用于生成一个组件类（组件名必须大写）
	var HelloMessage = React.createClass({
	  render: function() {
		return <h1>Hello World！</h1>;
	  }
	});
2.需要向组件传递参数，可以使用 this.props 对象
3.React State(状态)----getInitialState 方法用于定义初始状态，这个对象可以通过 this.state 属性读取。
4.组件中定义函数----如handleClick。
5.state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。
	它是通过props从父级传递来的吗？如果是，它可能不是 state。
	它随时间变化吗？如果不是,它可能不是 state。
	你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state.
	大部分组件的工作应该是从 props 里取数据并渲染出来。但是，有时需要对用户输入、服务器请求或者时间变化等作出响应，这时才需要使用 State。
	常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。
6.通过 getDefaultProps() 方法为 props 设置默认值。
7.state 和 props配合----我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。
8.Props 验证----使用propTypes有
	JS 基本数据类型array\bool\func\number\object\string\any。
	React 元素----element\React 节点----node\
	用 JS 的 instanceof 操作符声明 prop 为类的实例----React.PropTypes.instanceOf(Message)
	限定为其中的值----optionalEnum: React.PropTypes.oneOf(['News', 'Photos'])
	可以是多个对象类型中的一个----
		optionalUnion: React.PropTypes.oneOfType([
		  React.PropTypes.string,
		  React.PropTypes.number,
		  React.PropTypes.instanceOf(Message)
		])
	指定类型组成的数组----React.PropTypes.arrayOf(React.PropTypes.number)
	指定类型的属性构成的对象----React.PropTypes.objectOf(React.PropTypes.number)
	特定 shape 参数的对象----
		React.PropTypes.shape({
		  color: React.PropTypes.string,
		  fontSize: React.PropTypes.number
		}),
	任意类型加上 `isRequired` 来使 prop 不可空----requiredFunc: React.PropTypes.func.isRequired
	自定义验证器。如果验证失败需要返回一个 Error 对象----
		customProp: function(props, propName, componentName) {
		  if (!/matchme/.test(props[propName])) {
			return new Error('Validation failed!');
		  }
		}
9.React 组件 API 如；setState(object nextState[, function callback])
	设置或替换状态----setState/replaceState--
		replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。
	设置或替换属性----setProps/replaceProps
		当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。
	强制更新----forceUpdate--forceUpdate([function callback])
		forceUpdate()方法会使组件调用自身的render()方法重新渲染组件
		forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()
	获取DOM节点----findDOMNode--返回值：DOM元素DOMElement
		从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。
	判断组件挂载状态----isMounted--返回值：true或false，表示组件是否已挂载到DOM中
		可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。
10.React 组件生命周期
	组件的生命周期可分成三个状态：
		Mounting:已插入真实DOM----挂载getInitialState()、componentWillMount()、componentDidMount()
		Updating:正在被重新渲染----更新componentWillReceiveProps(object nextProps)、shouldComponentUpdate(object nextProps, object nextState)、componentWillUpdate(object nextProps, object nextState)、componentDidUpdate(object prevProps, object prevState)
		Unmounting:已移出真实DOM----卸载componentWillUnmount()、
	生命周期的方法有；will 方法，该方法在某事发生前被调用，did方法，在某事发生后被调用。
		（第一次触发）componentWillMount----在渲染前调用，在客户端也在服务端。
		（第一次触发）componentDidMount----在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 
			如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。
		componentWillReceiveProps----在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。
		shouldComponentUpdate----返回一个布尔值。在组件接收到新的props或者state时被调用。
			在初始化时或者使用forceUpdate时不被调用。 
			可以在你确认不需要更新组件时使用。
		componentWillUpdate----在组件接收到新的props或者state但还没有render时被调用。
			在初始化时不会被调用。
		componentDidUpdate----在组件完成更新后立即调用。
			在初始化时不会被调用。
		componentWillUnmount----在组件从 DOM 中移除的时候立刻被调用。
11.React AJAX
		React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。
	当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。配合jquery使用。
12.React 表单与事件
	父组件》》子组件，通过props
	子组件》》父组件，通过在父组件通过创建事件句柄 (handleChange) 
13.React Refs
		React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。
	这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。
	如：render中<input ref="myInput" />，使用var input = this.refs.myInput;
14.ReactDOM.render() 实例化根组件，启动框架，注入标记到原始的 DOM 元素中，作为第二个参数提供。
15.this.props.children----它表示组件的所有子节点
16.style={{color:'red'}}
17.具体步骤
	第一步：把UI拆分为一个组件的层级
	第二步：用React创建一个静态版本
	第三步：确定最小（但完备）的 UI state 表达
	第四步：确定你的 state 应该存在于哪里
		我们需要确定哪个组件可以改变，或者 拥有 这个state.
			确定哪些组件要基于 state 来渲染内容。
			找到一个共同的拥有者组件（在所有需要这个state组件的层次之上，找出共有的单一组件）。
			要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state。
			如果你不能找到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上。
	第五步：添加反向数据流		
18.Mixins----有时一些不同的组件间也需要共用一些功能			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			