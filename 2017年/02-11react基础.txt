1.React.createClass 方法用于生成一个组件类（组件名必须大写）
	var HelloMessage = React.createClass({
	  render: function() {
		return <h1>Hello World！</h1>;
	  }
	});
2.需要向组件传递参数，可以使用 this.props 对象
3.React State(状态)----getInitialState 方法用于定义初始状态，这个对象可以通过 this.state 属性读取。
4.组件中定义函数----如handleClick。
5.state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。
	它是通过props从父级传递来的吗？如果是，它可能不是 state。
	它随时间变化吗？如果不是,它可能不是 state。
	你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state.
	大部分组件的工作应该是从 props 里取数据并渲染出来。但是，有时需要对用户输入、服务器请求或者时间变化等作出响应，这时才需要使用 State。
	常用的模式是创建多个只负责渲染数据的无状态（stateless）组件，在它们的上层创建一个有状态（stateful）组件并把它的状态通过 props 传给子级。这个有状态的组件封装了所有用户的交互逻辑，而这些无状态组件则负责声明式地渲染数据。
6.通过 getDefaultProps() 方法为 props 设置默认值。
7.state 和 props配合----我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。
8.Props 验证----使用propTypes有
	JS 基本数据类型array\bool\func\number\object\string\any。
	React 元素----element\React 节点----node\
	用 JS 的 instanceof 操作符声明 prop 为类的实例----React.PropTypes.instanceOf(Message)
	限定为其中的值----optionalEnum: React.PropTypes.oneOf(['News', 'Photos'])
	可以是多个对象类型中的一个----
		optionalUnion: React.PropTypes.oneOfType([
		  React.PropTypes.string,
		  React.PropTypes.number,
		  React.PropTypes.instanceOf(Message)
		])
	指定类型组成的数组----React.PropTypes.arrayOf(React.PropTypes.number)
	指定类型的属性构成的对象----React.PropTypes.objectOf(React.PropTypes.number)
	特定 shape 参数的对象----
		React.PropTypes.shape({
		  color: React.PropTypes.string,
		  fontSize: React.PropTypes.number
		}),
	任意类型加上 `isRequired` 来使 prop 不可空----requiredFunc: React.PropTypes.func.isRequired
	自定义验证器。如果验证失败需要返回一个 Error 对象----
		customProp: function(props, propName, componentName) {
		  if (!/matchme/.test(props[propName])) {
			return new Error('Validation failed!');
		  }
		}
9.React 组件 API 如；setState(object nextState[, function callback])
	设置或替换状态----setState/replaceState--
		replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。
	设置或替换属性----setProps/replaceProps
		当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。
	强制更新----forceUpdate--forceUpdate([function callback])
		forceUpdate()方法会使组件调用自身的render()方法重新渲染组件
		forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()
	获取DOM节点----findDOMNode--返回值：DOM元素DOMElement
		从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。
	判断组件挂载状态----isMounted--返回值：true或false，表示组件是否已挂载到DOM中
		可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。
10.React 组件生命周期
	组件的生命周期可分成三个状态：
		Mounting:已插入真实DOM----挂载getInitialState()、componentWillMount()、componentDidMount()
		Updating:正在被重新渲染----更新componentWillReceiveProps(object nextProps)、shouldComponentUpdate(object nextProps, object nextState)、componentWillUpdate(object nextProps, object nextState)、componentDidUpdate(object prevProps, object prevState)
		Unmounting:已移出真实DOM----卸载componentWillUnmount()、
    React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。    
        componentWillMount()
        componentDidMount()----ajax、setTimeout、setInterval在这里处理。
        componentWillUpdate(object nextProps, object nextState)
        componentDidUpdate(object prevProps, object prevState)
        componentWillUnmount()----当组件被移除时，释放组件已经占用的资源是非常重要的。
    React 还提供两种特殊状态的处理函数:
        componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
        shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用
11.React AJAX
		React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。
	当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。配合jquery使用。
12.React 表单与事件
	父组件》》子组件，通过props
	子组件》》父组件，通过在父组件通过创建事件句柄 (handleChange) 
13.React Refs
		React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。
	这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。
	如：render中<input ref="myInput" />，使用var input = this.refs.myInput;
14.ReactDOM.render() 实例化根组件，启动框架，注入标记到原始的 DOM 元素中，作为第二个参数提供。
15.this.props.children----它表示组件的所有子节点
16.style={{color:'red'}}
17.具体步骤
	第一步：把UI拆分为一个组件的层级
	第二步：用React创建一个静态版本
	第三步：确定最小（但完备）的 UI state 表达
	第四步：确定你的 state 应该存在于哪里
		我们需要确定哪个组件可以改变，或者 拥有 这个state.
			确定哪些组件要基于 state 来渲染内容。
			找到一个共同的拥有者组件（在所有需要这个state组件的层次之上，找出共有的单一组件）。
			要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state。
			如果你不能找到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上。
	第五步：添加反向数据流		
18.Mixins----有时一些不同的组件间也需要共用一些功能			
19.ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。			
20.遍历一个数组插入节点中			
	{
        names.map(function(name) {
            return <h1>Hello {name} !</h1>
        })
    }		
21.插入JavaScript变量，变量可以为数字，obj等等。			
22.封装组件,3种方式
    var Hello = React.createClass(render(){return...});
    function Hello(props){return...}         //使用是为props.name无状态和周期hook
    class Hello extens React.Component{render(){return...}}
23.PropsType----propTypes:{title:React.PropTypes.string.isRequired,}


24.组件通信
    （父》子，子》父）我们就实现了一个模态弹窗的基本逻辑，通过传递props，父组件可以控制子组件的状态，而子组件也通过调用父组件传进来的props方法，来通知父元素改变状态来达到影响自己的目的（比如关闭弹窗）。			
    （子》子）子组件之间的通讯也是一样，一个子组件想作用另一个子组件，可以通过父组件来做中间调度，对于子组件来说，父组件就是一个公共环境，它的一切资源，想调用的话，直接通过props接收就可以了。		
25. key 属性
	React 会提示对于循环输出的组件，需要有一个唯一的 key 属性----实现渲染优化。		
			
			
			


































			
			
			
			
			
			
			