最近js相关的基础性东西，应该就看到这里。逐步学习学习更高级的东西
第一部分 类型和语法
一.类型
	1.1类型
	1.2内置类型
		空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、对象（object）、符号（symbol）
		除对象以外其余为基本类型，可以通过 typeof来查看值的类型，返回为string类型
		undefined、boolean、number、string、symbol、object（null、array、function）
	1.3值和类型
		undefined 和 undeclared
			在作用域中已声明但还没有赋值的变量 --- undefined
			在作用域中没有声明 --- undeclared
		typeof Undeclared
			typeof有安全防范机制
				if( typeof DEBUG !== 'undefined' ){ console.log('开始调试') }
			依赖注入：将依赖通过参数显式地传递到函数中。
		应用：使用typeof的安全防范机制来检查undeclared变量，或者是依赖注入。
二.值
	2.1数组
		delete运算符可以删除数组单元格，但数组长度不发生改变。
		稀疏数组 --- 含有空白或空缺单元的数组
		类数组 DOM元素列表、arguments
			es5转化为数组 -- [].slice.call( arguments );
			es6转化为数组 -- Array.from( arguments );
	2.2字符串
		字符串操作不改变原始值   c = a.toUpperCase(); a === c //false
		数组有一个字符串没有的可变更成员函数 -- 反转reverse()
	2.3数字
		数字的语法
			toExponential() -- 科学计数法，输出为number类型
			toFixed() -- 指定小数位数，但输出的是string类型
			toPrecision() -- 指定有效位数，输出为string类型
		0o363/0O363表示8进制
		较小的数值
			Number.EPSILON -- 误差范围值（机器精度）
			Number.MAX_VALUE -- 最大的浮点数
			Number.MIN_VALUE -- 最大的浮点数（接近于0）
		整数的安全范围
			Number.MAX_SAFE_INTEGER -- 最大整数
			Number.MIN_SAFE_INTEGER -- 最小整数
		整数检测
			Number.isInteger()
			Number.isSafeInteger()
		32位有符号整数
			a | 0 可以得到32位有符号整数
	2.4特殊数值
		undefined -- undefined（没有值）
		null -- null（空值）
		null 是特殊关键字		
		undefined 是一个标识符	
		void 运算符 -- 	没有返回值，返回结果是undefined
			应用；将代码的值设置为 undefined，就可以使用void
		特殊的数字
			不是数字的数字 -- NaN，无效数值
				Number.isNaN()
			无穷数
				Infinity == Number.POSITIVE_INFINITY
				-Infinity == Number.NEGATIVE_INFINITY
			零值
				-0/+0
			特殊等式
				==、===、Object.is()
	2.5值和引用
		简单值 -- 通过值复制的方式来赋值/传递。（null、undefined、字符串、数字、布尔、symbol）
		复合值 -- 通过引用复制的方式来赋值/传递。	
			var c = [1, 2, 3];
			var d = c;  //c、d分别指向同一个复合值[1, 2, 3]的两个不同的引用，是对值[1, 2, 3]的引用
			c.push( 4 ); //所以更改一个都会发生改变
			//c、d都为[1, 2, 3, 4]
			一个引用无法改变另一个引用的指向
			var d = [4, 5, 6];
			//c为[1, 2, 3];d为[4, 5, 6];
			我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。	
			应用：
			通过值复制的方式来传递复合值（如数组），需要为其创建一个副本，这样传递的就不是原始值。
				array.slice();  //新建了一个数组，其实为原数组的浅拷贝
			如果要将标量基本类型值传递到函数内进行更改，就需要将值封装到一个复合值（对象、数组），然后通过引用复制的方式传递。	
三.原生函数
	String()/Number()/Boolean()/Array()/Object()/Function()/Regexp()/Date()/Error()/Symbol()
	3.1内部属性[[Class]]				
		对于typeof 返回object可以使用Object.prototype.toString()
		使用Object.prototype.toString.call([1, 2]); [object Array]
	3.2封装对象包装
		var a = new String( 'fan' );
		封装对象释疑
	3.3拆封
		通过valueOf() -- 得到封装对象中的基本类型值
	3.4原生函数作为构造函数
		Array()
		Object()/Function()/RegExp()
		Date()/Error()
			throw new Error('error');
		Symbol()
			用作属性名，但代码和控制台都无法查看和访问它的值
			静态属性Symbol.create/Symbol.iterator
			应用：替代私有属性，但可以通过Object.getOwnPropertySymbols()访问
		原生原型
			String.prototype --- 原型对象 String.prototype.indexOf()
四.强制类型转换
	4.1值类型转换
		var a = 42;
		var b = a + '';  隐式转换
		var c = String( a );  显示转换
	4.2抽象值操作
		ToString 对于Number\Array
			JSON.parse(str[, reviver]) -- js字符串转化为json
			JSON.stringify(json[, replacer [, space]])  -- json转化为js字符串
		ToNumber
			先valueOf()再toString()
			Object.create(proto, [ propertiesObject ])
		ToBoolean
			假值列表：undefined、null、false、+0、-0、NaN、""（空字符串）
	4.3显示强制类型转换	
		string -- number 之间的显式转换
		String() 和 Number() 显式转换
		a.toString() -- 数字转化为字符串
		var b = +a; -- 字符串转化为数字
		日期显示转化为数字 -- var d = new Date(); +d;//转化为数字
			还有 d.getTime()转化为时间戳
			es5 -- Date.now()
		~x  ===  -(X+1) 也就是说 ~(-1) === -0此时-0为假值
			~a.indexOf('ol') a中存在'ol'就为真，不存在就为假
		显式解析数字字符串
			Number() -- 转换（遇非数字转换失败NaN）
			parseInt( str, radix ) -- 解析（从左到右，遇非数字停止）
		显式转换为布尔值
			!!反转回原值
			Boolean()
	4.4隐式强制类型转换
		隐式地简化
		字符串和数字之间地隐式强制类型转换
			number + ''; //返回为string
			string - 0;  //返回为number
		布尔值到数字地隐式强制类型转换
		隐式强制类型转换为布尔值		
		|| 和 && 操作数选择器运算符
			a||b  //对于a能强制转化为true时返回a，否则返回b，等价于a ? a : b
			a&&b  //对于a能强制转化为true时返回b，否则但会a，等价于a ? b : a
			a&&foo() //类似于if(a){ foo() } 称为短路
		符号地强制类型转换
	4.5宽松相等和严格相等
		 == 允许在相等比较中进行强制类型转换，而 === 不允许
		使用 === true / == true 少用	
		null == undefined //true
		比较少见地情况（避免使用）
			"0" == false; // true -- 晕！
			false == 0; // true -- 晕！
			false == ""; // true -- 晕！
			false == []; // true -- 晕！
			"" == 0; // true -- 晕！
			"" == []; // true -- 晕！
			0 == []; // true -- 晕！
			如果两边的值中有 true 或者 false ，千万不要使用 == 。
			如果两边的值中有 [] 、 "" 或者 0 ，尽量不要使用 == 。
	4.6抽象关系比较
五.语法
	5.1语句和表达式
		语句的结果值
		表达式的副作用
		上下文规则
		没有 else if
	5.2运算符优先级
		&& 优先于 ||
		短路 -- opts && opts.cool
		更强的绑定
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	
	
	
	
	
	
	
	
	
	
	
	

