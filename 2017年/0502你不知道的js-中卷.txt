最近js相关的基础性东西，应该就看到这里。逐步学习学习更高级的东西
第一部分 类型和语法
一.类型
	1.1类型
	1.2内置类型
		空值（null）、未定义（undefined）、布尔值（boolean）、数字（number）、字符串（string）、对象（object）、符号（symbol）
		除对象以外其余为基本类型，可以通过 typeof来查看值的类型，返回为string类型
		undefined、boolean、number、string、symbol、object（null、array、function）
	1.3值和类型
		undefined 和 undeclared
			在作用域中已声明但还没有赋值的变量 --- undefined
			在作用域中没有声明 --- undeclared
		typeof Undeclared
			typeof有安全防范机制
				if( typeof DEBUG !== 'undefined' ){ console.log('开始调试') }
			依赖注入：将依赖通过参数显式地传递到函数中。
		应用：使用typeof的安全防范机制来检查undeclared变量，或者是依赖注入。
二.值
	2.1数组
		delete运算符可以删除数组单元格，但数组长度不发生改变。
		稀疏数组 --- 含有空白或空缺单元的数组
		类数组 DOM元素列表、arguments
			es5转化为数组 -- [].slice.call( arguments );
			es6转化为数组 -- Array.from( arguments );
	2.2字符串
		字符串操作不改变原始值   c = a.toUpperCase(); a === c //false
		数组有一个字符串没有的可变更成员函数 -- 反转reverse()
	2.3数字
		数字的语法
			toExponential() -- 科学计数法，输出为number类型
			toFixed() -- 指定小数位数，但输出的是string类型
			toPrecision() -- 指定有效位数，输出为string类型
		0o363/0O363表示8进制
		较小的数值
			Number.EPSILON -- 误差范围值（机器精度）
			Number.MAX_VALUE -- 最大的浮点数
			Number.MIN_VALUE -- 最大的浮点数（接近于0）
		整数的安全范围
			Number.MAX_SAFE_INTEGER -- 最大整数
			Number.MIN_SAFE_INTEGER -- 最小整数
		整数检测
			Number.isInteger()
			Number.isSafeInteger()
		32位有符号整数
			a | 0 可以得到32位有符号整数
	2.4特殊数值
		undefined -- undefined（没有值）
		null -- null（空值）
		null 是特殊关键字		
		undefined 是一个标识符	
		void 运算符 -- 	没有返回值，返回结果是undefined
			应用；将代码的值设置为 undefined，就可以使用void
		特殊的数字
			不是数字的数字 -- NaN，无效数值
				Number.isNaN()
			无穷数
				Infinity == Number.POSITIVE_INFINITY
				-Infinity == Number.NEGATIVE_INFINITY
			零值
				-0/+0
			特殊等式
				==、===、Object.is()
	2.5值和引用
		简单值 -- 通过值复制的方式来赋值/传递。（null、undefined、字符串、数字、布尔、symbol）
		复合值 -- 通过引用复制的方式来赋值/传递。	
			var c = [1, 2, 3];
			var d = c;  //c、d分别指向同一个复合值[1, 2, 3]的两个不同的引用，是对值[1, 2, 3]的引用
			c.push( 4 ); //所以更改一个都会发生改变
			//c、d都为[1, 2, 3, 4]
			一个引用无法改变另一个引用的指向
			var d = [4, 5, 6];
			//c为[1, 2, 3];d为[4, 5, 6];
			我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。	
			应用：
			通过值复制的方式来传递复合值（如数组），需要为其创建一个副本，这样传递的就不是原始值。
				array.slice();  //新建了一个数组，其实为原数组的浅拷贝
			如果要将标量基本类型值传递到函数内进行更改，就需要将值封装到一个复合值（对象、数组），然后通过引用复制的方式传递。	
三.原生函数
	String()/Number()/Boolean()/Array()/Object()/Function()/Regexp()/Date()/Error()/Symbol()
	3.1内部属性[[Class]]				
		对于typeof 返回object可以使用Object.prototype.toString()
		使用Object.prototype.toString.call([1, 2]); [object Array]
	3.2封装对象包装
		var a = new String( 'fan' );
		封装对象释疑
	3.3拆封
		通过valueOf() -- 得到封装对象中的基本类型值
	3.4原生函数作为构造函数
		Array()
		Object()/Function()/RegExp()
		Date()/Error()
			throw new Error('error');
		Symbol()
			用作属性名，但代码和控制台都无法查看和访问它的值
			静态属性Symbol.create/Symbol.iterator
			应用：替代私有属性，但可以通过Object.getOwnPropertySymbols()访问
		原生原型
			String.prototype --- 原型对象 String.prototype.indexOf()
四.强制类型转换
	4.1值类型转换
		var a = 42;
		var b = a + '';  隐式转换
		var c = String( a );  显示转换
	4.2抽象值操作
		ToString 对于Number\Array
			JSON.parse(str[, reviver]) -- js字符串转化为json
			JSON.stringify(json[, replacer [, space]])  -- json转化为js字符串
		ToNumber
			先valueOf()再toString()
			Object.create(proto, [ propertiesObject ])
		ToBoolean
			假值列表：undefined、null、false、+0、-0、NaN、""（空字符串）
	4.3显示强制类型转换	
		string -- number 之间的显式转换
		String() 和 Number() 显式转换
		a.toString() -- 数字转化为字符串
		var b = +a; -- 字符串转化为数字
		日期显示转化为数字 -- var d = new Date(); +d;//转化为数字
			还有 d.getTime()转化为时间戳
			es5 -- Date.now()
		~x  ===  -(x+1) 也就是说 ~(-1) === -0此时-0为假值
			~a.indexOf('ol') a中存在'ol'就为真，不存在就为假
		显式解析数字字符串
			Number() -- 转换（遇非数字转换失败NaN）
			parseInt( str, radix ) -- 解析（从左到右，遇非数字停止）
		显式转换为布尔值
			!!反转回原值
			Boolean()
	4.4隐式强制类型转换
		隐式地简化
		字符串和数字之间地隐式强制类型转换
			number + ''; //返回为string
			string - 0;  //返回为number
		布尔值到数字地隐式强制类型转换
		隐式强制类型转换为布尔值		
		|| 和 && 操作数选择器运算符
			a||b  //对于a能强制转化为true时返回a，否则返回b，等价于a ? a : b
			a&&b  //对于a能强制转化为true时返回b，否则但会a，等价于a ? b : a
			a&&foo() //类似于if(a){ foo() } 称为短路
		符号地强制类型转换
	4.5宽松相等和严格相等
		 == 允许在相等比较中进行强制类型转换，而 === 不允许
		使用 === true / == true 少用	
		null == undefined //true
		比较少见地情况（避免使用）
			"0" == false; // true -- 晕！
			false == 0; // true -- 晕！
			false == ""; // true -- 晕！
			false == []; // true -- 晕！
			"" == 0; // true -- 晕！
			"" == []; // true -- 晕！
			0 == []; // true -- 晕！
			如果两边的值中有 true 或者 false ，千万不要使用 == 。
			如果两边的值中有 [] 、 "" 或者 0 ，尽量不要使用 == 。
	4.6抽象关系比较
五.语法
	5.1语句和表达式
		语句的结果值
		表达式的副作用
		上下文规则
		没有 else if
	5.2运算符优先级
		&& 优先于 ||
		|| 优先于 ? : （三目运算符）
		短路 -- opts && opts.cool
		更强的绑定
		关联（结合性）
		关联的意思是从右往左组合，而不是从右往左执行。
		&& 和 || 是左关联
			如：a && b && c    左关联，(a && b) && c
		? :(三元运算符)是右关联
			如：a ? b : c ? d : e   右关联，a ? b : ( c ? d : e )
		右关联的有三元运算符(a?b:c)、一元运算符、赋值运算符(=)
			一元运算符：delete、void、++、--、+、-
		进行运算时，需要考虑优先级 和 关联
		释疑
			通过优先级、关联规则 和 ()来控制代码优先级
	5.3自动分号
		break 、 continue 、 return 和 yield （ES6）等关键字会添加分号;
	5.4错误
		提前使用变量 TDZ暂时性死区。变量还没有初始化而不能被引用
		try{ }catch(){}	
	5.5函数参数
	5.6try...finally	
	5.7switch
		switch( a ){
			case 2:
				...
				break;
		}
		其中a表达式与case值 是通过 ===判断的
		case中也可以为表达式，如 case 2+1:
附录A -- 混合环境javascript
	A.1 Annex B（ECMAScript）
		Web ECMAScript		
	A.2宿主对象
		包括内建对象和函数，如：div、console
	A.3全局DOM变量
		html中id属性为全局变量
		<div id=cc></div>  console.log(cc); //<div id=cc></div>
	A.4原生原型
		不要扩展原生原型
		shim/polyfill
		shim(有兼容性测试)
		polyfill(检查功能是否存在)
	A.5<script>	
		在前一个script标签中使用后面定义定义的函数会出错 -- 全局变量作用域的提升机制不适用了。
		<script>foo();</script>
		<script>
		function foo() { .. }
		</script>
		//报错
	A.6保留字
		老版本浏览器中保留字不可以作为属性
	A.7实现中的限制	
第二部分--异步和性能
一.异步：现在与未来
	异步的方式：1回调函数，2promise，3generator（生成器），4asyn函数	
	1.1分块的程序
		定时器、鼠标点击、Ajax响应等都是异步机制
		异步控制台
	1.2事件循环
		setTimeout()并不是将你的回调函数挂在事件循环队列中，当定时器到时后，环境会把你的回调函数放在事件循环中，在根据事件循环队里来执行。
	1.3并行线程
		异步 -- 关于现在和将来的时间间隔
		并行 -- 关于能够同时发生的事情
		完整运行
	1.4并发
		非交互 -- 进程间没有相互影响
		交互 -- 进程间通过作用域或DOM间接交互
		协作 -- 将一个长期运行的进程分割成多个任务。
			如：10万的数组，分隔成1000的小数组进行处理
	1.5任务	
		事件循环队列 之上 任务队列
		有点类似于setTimeout( ..., 0);
	1.6语句顺序
二.回调
	2.1continuation
	2.2顺序的大脑
		执行与计划
		嵌套回调与链式调用
	2.3信任问题
		五个回调的故事
		不只是别人的代码
	2.4省点回调		
三.promise	
	3.1什么是promise
		未来值
		promise是一种封装和组合（未来值）的易于复用的机制
		完成事件





















	
	
	
	


	
	
	
	
	
	
	