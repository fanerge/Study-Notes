本文为2017年0416周日，读你不知道的javascript系列书籍所做的笔记。
第一部分.作用域和闭包
一.作用域是什么
	1.1编译原理（编译器完成）
		分词/词法分析 >> 解析/语法分析 >> 代码生成(机器指令)
		其编译发生在代码执行前几微秒。
	1.2理解作用域
		引擎 + 编译器 + 作用域
	1.3作用域嵌套
		当一个块或(函数)嵌套在另一个块或(函数)中时，就发生了作用域的嵌套。
	1.4异常
		LRS --- 赋值操作的目标时谁
		RHS --- 谁是赋值操作的源头
	1.5小结 
		如果查找的目标是对变量进行赋值，那么就会使用LHS查询。
		如果目标是获取变量的值，就会使用RHS查询。
二.词法作用域
	2.1词法阶段
	2.2欺骗词法	
		eval\setTimeout\setInterval\new Function //传递字符串作为参数，避免使用
		with（通常被当做重复引用同一对象中的多个属性的快捷方式），避免使用
三.函数作用域和块级作用域
	3.1函数中的作用域
	3.2隐藏内部实现（私有成员）
	3.3函数作用域
	3.4块级作用域
		1.with( obj ){
			a = 3; //等价于obj.a = 3;
		}
		2.try{
			
		}catch( e ){  //e代表错误
			
		}
		3.let --- 在{}中声明变量
			垃圾收集
			let循环
		4.const
四.提升
	4.1先有鸡还是先有蛋
	4.2编译器再度来袭
		变量(var)和函数声明都会提前 --- 提升（var a = 1;会被拆分为变量声明和变量赋值，只是提升了变量声明）
			拆分为var a; --- 在编译阶段 和 a = 1; --- 在执行阶段
		函数表达式 --- 不提升，相当与变量提升，也就是声明提前了，但值为undefined
	4.3函数优先
		函数会被首先提升，然后才是变量。(也就是说，同名的函数和变量，函数会被提升到最前面)
五.作用域闭包
	5.1启示
	5.2实质问题
		闭包就是能够读取其他函数内部变量的函数。
		由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
	5.3现在我懂了
	5.4循环和闭包	
	5.5模块	
		CMD、AMD
		ES6 --- import、export
附录A.动态作用域		
	作用域：词法作用域 --- 定义时确定 、 动态作用域(this) --- 执行时确定
附录B.块作用域的替代方案	
	1.try{
		throw 2;
	}catch( e ){
		console.log( e );
	}
	2.Traceur、Bable
	3.隐式和显示作用域
附录C.this词法
	箭头函数 --- 本身没有this，从父级哪里继承this
	可以使用bind()方法
第二部分.this和对象原型
一.关于this
	this指向为该函数执行的环境（调用方式），在运行时绑定的。
	1.为什么要用this
	2.误解
		foo.call( foo, i); //将强制foo中的this指向foo
	3.this到底是什么
二.this全面解析
	1.调用位置
	2.绑定规则
		默认绑定（普通函数this指向window），但在严格模式中 this 指向undefined
		隐式绑定（对象中的函数this指向对象），对象属性引用链中只有最顶层会影响调用位置。
			隐式丢失 --- var bar = obj.foo;(只是对函数的引用),这是bar函数this指向window
			回调函数丢失this
		显示绑定 （call()、apply()）
			fun.apply( obj, arguements ); //将fun的this指向obj	
			fun.bind( obj );  //方法会创建一个新函数,并将this指向obj，函数柯里化
		new绑定（指向它的实例）
	3.优先级
		new绑定 > 显示绑定 > 隐式绑定 > 默认绑定
	4.绑定例外
	5.this词法		
		箭头函数 --- 根据外层(函数或者全局)作用域来决定this。其实箭头函数是没有this的
		箭头函数 （可以用于回调函数中，这样就不用重写绑定this了）	
三.对象
	1.语法
		字面量 和 构造形式
	2.类型
		7种类型（string、number、boolean、null、undefined、symbol、object（function 和 array））
		简单基本类型（string、boolean、number、null、undefined、symbol）
		内置对象（String、Number、Boolean、Object、Function、Array、Date、RegExp、Error）
			null 和 undefined 是没有构造形式的，而 Date 只有构造形式。
	3.内容
		可计算属性名 --- obj[prefix + name]
		属性 和 方法 --- 
		数组 --- 
			你向数组添加属性，数组的长度并不会发生改变。
		复制对象 --- 浅复制（直接属性）、深复制	
			浅复制 --- Object.assign(target, ...sources)将所有sources对象中可枚举的属性赋值(=)到target对象上
			区别在于层数问题
		属性描述符
			//获取obj.a的value、writable(修改)、enumerable(枚举)、configurable(配置，重新设置属性描述符，还会禁止删除这个属性)等属性描述符
			Object.getOwnPropertyDescriptor(obj, a);  
			//创建或修改obj.a的属性描述符
			Object.defineProperty(obj, 'a', {
				value: 2,
				wirtable: true,
				configurable: true,
				enumerable: true
			});	
		不变性（浅不可变，单层的不变）
			对象常量 --- writable: false 和 configurable: false (不可修改、配置、删除)
			禁止扩展 --- Object.preventExtensions() 禁止添加新属性且保留已有属性
				Object.isExtensible()
			密封 --- Object.seal() 密封，不能添加新属性、配置和删除，但可以修改属性
				Object.isSealed()
				实际上调用了Object.preventExtendions() 和 configurable: false
			冻结 --- Object.freeze() 冻结，级别最高的不可变性 
				Object.isFrozen()
				实际上调用Object.seal() 和 writable: false
		[[Get]]
			先自身查找属性，再[[protorype]]中查找
		[[put]]
			为对象的属性赋值会触发[[put]],分该属性存在与否？
		Getter 和 Setter
			let Obj = {
				//给a定义一个getter
				get a(){
					return 2;
				}
			};
			Obj.a = 3;
			Obj.a;   //2 获取就会调用get方法
			通常这样使用
			let Obj = {
				//为a定义一个getter
				get a(){
					return this._a_;
				},
				//为a定义一个setter
				set a( val ){
					return this._a_ = val * 2;
				}
			};
			//Obj.a = 2; 调用setter
			//Obj.a;   4 调用getter
		存在性
			in --- 如：'a' in Obj（检查属性是否在对象及其[[prototype]]中）
			hasOwnProperty() 如：Obj.hasOwnProperty('a')（检查属性是否在对象自身中）
		
		判断是否可枚举
			Obj.propertyIsEnumerable('a');  //是否直接在对象中,并可枚举
			Object.keys();  //返回一个数组，包含自身可枚举属性  
			Object.getOwnPropertyNames();  //返回一个数组，自身属性（包括不可枚举的属性）
	4.遍历
		数组 --- for、forEach、every、some、map
			forEach --会遍历数组中的所有元素并忽略回调函数的返回值
			every -- 一直运行到函数返回false
			some -- 一直运行到函数返回true
			map -- 返回一个新的数组
		for...of直接遍历值而不是数组下标 或者 对象属性
			数组有内置的迭代器 let it = array[Symbol.iterator](),it.next(); 
四.混合对象‘类’
	1.类理论	
		继承(Vehicle、Car)、实例化（建筑设计图-类和房子-实例）、多态(父类和子类具有相同的方法，子类重写该方法)
	2.类的机制
	3.类的继承
		多态 --- 重写父类方法
		多重继承 --- 
	4.混入  （模拟类语言中的复制行为）
		库的extend() 或 mixin()
			function mixin( sourceObj, targetObj ){
				for( let key in sourceObj ){
					//只会再不存在子类中进行复制
					if( !(key in targetObj) ){
						targetObj[key] = sourceObj[key];
					}
				}
			}
		显式多态 --- Vehicle.drive.call( this ); 再Car 中 进行 
五.原型
	1.[[prototype]]内置属性		
		Object.create( prototypeChian, { ... } );
		Object.prototype --- 尽头
			使其拥有了toString()、valueOf()、hasOwnproperty()、isPrototypeOf()等方法
	2.类
		javascript只有对象
		类函数
		构造函数 
			通过new调用时 它会创建一个对象
	3.(原型)继承		
		Bar.prototype = Object.create( Foo.prototype );	代替一下两种方式
		Bar.prototype = Foo.Prototype; //Bar.protorype做操纵时会修改Foo.Prototype
		Bar.prototype = new Foo();
			Object.setPrototypeOf(); 代替之前的__proto__属性修改关联
			Object.setPrototypeOf(obj, prototype); obj为要设置原型的对象，prototype为待设置的原型
		检查‘类’关系
			a instanceof Foo; //true
			Foo.prototype.isPrototypeOf( a ); //判断Foo.prototype是否存在与a的原型链上
			Object.getPrototypeOf( a ); //获取a的原型链
			a.__proto__; //访问a的原型链
	4.对象关联
		let a = Object.create( b, ...propertys ); //创建一个原型为b 的对象a
		let a = Object.create( null ); //完全空的对象，可用于存储数据
		
		
		
		



		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		

