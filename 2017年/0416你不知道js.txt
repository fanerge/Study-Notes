本文为2017年0416周日，读你不知道的javascript系列书籍所做的笔记。
第一部分.作用域和闭包
一.作用域是什么
	1.1编译原理（编译器完成）
		分词/词法分析 >> 解析/语法分析 >> 代码生成(机器指令)
		其编译发生在代码执行前几微秒。
	1.2理解作用域
		引擎 + 编译器 + 作用域
	1.3作用域嵌套
		当一个块或(函数)嵌套在另一个块或(函数)中时，就发生了作用域的嵌套。
	1.4异常
		LRS --- 赋值操作的目标时谁
		RHS --- 谁时赋值操作的源头
	1.5小结 
		如果查找的目标是对变量进行赋值，那么就会使用LHS查询。
		如果目标是获取变量的值，就会使用RHS查询。
二.词法作用域
	2.1词法阶段
	2.2欺骗词法	
		eval\setTimeout\setInterval\new Function //传递字符串作为参数，避免使用
		with（通常被当做重复引用同一对象中的多个属性的快捷方式），避免使用
三.函数作用域和块级作用域
	3.1函数中的作用域
	3.2隐藏内部实现（私有成员）
	3.3函数作用域
	3.4块级作用域
		1.with( obj ){
			a = 3; //等价于obj.a = 3;
		}
		2.try{
			
		}catch( e ){  //e代表错误
			
		}
		3.let --- 在{}中声明变量
			垃圾收集
			let循环
		4.const
四.提升
	4.1先有鸡还是先有蛋
	4.2编译器再度来袭
		变量(var)和函数声明都会提前 --- 提升（var a = 1;会被拆分为变量声明和变量赋值，知识提升了变量声明）
			拆分为var a;在编译阶段 和 a = 1;在执行阶段
		函数表达式 --- 不提升，相当与变量提升，也就是声明提前了，但值为undefined
	4.3函数优先
		函数会被首先提升，然后才是变量。(也就是说，同名的函数和变量，函数会被提升到最前面)
五.作用域闭包
	5.1启示
	5.2实质问题
		闭包就是能够读取其他函数内部变量的函数。
		由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。
	5.3现在我懂了
	5.4循环和闭包	
	5.5模块	
		CMD、AMD
		ES6 --- import、export
附录A.动态作用域		
	作用域：词法作用域 --- 定义时确定 、 动态作用域(this) --- 执行时确定
附录B.块作用域的替代方案	
	1.try{
		throw 2;
	}catch( e ){
		console.log( e );
	}
	2.Traceur、Bable
	3.隐式和显示作用域
附录C.this词法
	箭头函数 --- 本身没有this，重父级哪里继承this
	可以使用bind()方法
第二部分.this和对象原型
一.关于this
	this指向为该函数执行的环境。
	1.为神要用this












































